/*
 * 程序名：tcpFile.cpp， 采用tcp协议， 实现文件上传的客户端。
*/
#include"public.h"

//程序运行的参数结构体。
struct st_arg
{
  int clienttype; //客户端类型，1-上传文件； 2-下载文件
  char ip[31];    //服务端的IP地址
  int port;       //服务端的端口
  int ptype;      //文件上传成功后的处理方式：1-删除文件；2-移动到备份目录
  char clientpath[301];    //本地文件存放的根目录
  char clientpathbak[301];  //文件成功上传后，本地文件备份的根目录，当ptype==2时有效
  bool andchild;            //是否上传clientpath目录次下各级子目录的文件，true-是，false-否
  char matchname[301];      //待上传文件名的匹配方式，如“。TxT”，“XML”
  char srvpath[301];        //服务端文件存放的根目录
  int timetvl;              //扫描本地目录文件的时间间隔，单位：秒              
  int timeout;              //进程心跳的超时时间
  char pname[51];           //进程名，建议用“tcpgetfiles_后缀”的方式
} starg;

//把xml解析到参数starg结构中
bool _xmltoArg(char *str_xmlBuffer);

CLogFile logfile; //服务程序的运行日志
CTcpClient TcpClient;

char strRecvBuffer[1024]; //发送报文的buffer
char strSendBuffer[1024]; //接收报文的buffer

//程序退化和信号2，15 的处理函数。
void EXIT(int sig);

void _help();

//把xml解析到参数starg结构中
bool _xmltoArg(char *strxmlBuffer);

bool Login(const char *argv);  //登录

bool ActiveTest(); //心跳

CPActive PActive; //进程心跳


int main(int argc,char *argv[])
{
  if (argc!=3) { _help(); return -1; }

  // 关闭全部的信号和输入输出。
  // 设置信号,在shell状态下可用 "kill + 进程号" 正常终止些进程。
  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);

  // 打开日志文件。
  if (logfile.Open(argv[1],"a+")==false)
  {
    printf("Open log failed(%s).\n",argv[1]); return -1;
  }

  // 解析xml，得到程序运行的参数。
  if (_xmltoArg(argv[2])==false){
    logfile.Write("XML wrong.\n");
   return -1;
  }

  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。

  // 向服务端发起连接请求。
  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)
  {
    logfile.Write("TcpClient.ConnectToServer(%s,%d) failed.\n",starg.ip,starg.port); EXIT(-1);
  }

  // 登录业务。
  if (Login(argv[2])==false) { logfile.Write("Login() failed.\n"); EXIT(-1); }

  for (int ii=3;ii<5;ii++)
  {
    if (ActiveTest()==false) break;

    sleep(ii);
  }
   
  EXIT(0);
}

// 心跳。 
bool ActiveTest()    
{
  memset(strSendBuffer,0,sizeof(strSendBuffer));
  memset(strRecvBuffer,0,sizeof(strRecvBuffer));
 
  SPRINTF(strSendBuffer,sizeof(strSendBuffer),"<activetest>ok</activetest>");
   logfile.Write("Active Send: %s\n",strSendBuffer);
  if (TcpClient.Write(strSendBuffer)==false) return false; // 向服务端发送请求报文。

  if (TcpClient.Read(strRecvBuffer,20)==false) return false; // 接收服务端的回应报文。
   logfile.Write("Active Recv: %s\n",strRecvBuffer);

  return true;
}

// 登录业务。 
bool Login(const char *argv)    
{
  memset(strSendBuffer,0,sizeof(strSendBuffer));
  memset(strRecvBuffer,0,sizeof(strRecvBuffer));
 
  SPRINTF(strSendBuffer,sizeof(strSendBuffer),"%s<clienttype>1</clienttype>",argv);
  logfile.Write("send:%s\n",strSendBuffer);
  if (TcpClient.Write(strSendBuffer)==false)// 向服务端发送请求报文。
  {
  logfile.Write("tcpClient Write to strSendBuffer wrong");
   return false; // 向服务端发送请求报文。
  }
  if (TcpClient.Read(strRecvBuffer,20)==false){// 接收服务端的回应报文。
  logfile.Write("tcpClient Read to strRecvBuffer wrong");
  return false;
  }
  
  logfile.Write("recevie:%s\n",strRecvBuffer);

  logfile.Write("Login (%s:%d)success.\n",starg.ip,starg.port); 

  return true;
}

//退出进程函数
void EXIT(int sig)
{
  logfile.Write("process exit, sig=%d\n\n",sig);

  exit(0);
}

void _help()
{
  printf("\n");
  printf("Using:/home/mininet/demo/net/tcpFiles logfilename xmlbuffer\n\n");

  printf("Sample:/project/tools1/bin/procctl 20 ./tcpFiles /home/mininet/demo/net/tcpFiles/tcpFile.log \"<ip>192.168.174.128</ip><port>5005</port><ptype>1</ptype><clientpath>/home/mininet/demo/net/tcpFiles</clientpath><clientpathbak>/home/mininet/demo/net/tcpFiles</clientpathbak><andchild>true</andchild><matchname>*.xml,*.SCV,*.JSON</matchname><srvpath>/home/mininet/demo/net/tcpFiles</srvpath><timetvl>10</timetvl><timeout>50</timeout><pname>tcpputfiles_surfdata</pname>\"\n");
  printf("/home/mininet/demo/net/tcpFiles 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \"<ip>192.168.174.128</ip><port>5005</port><ptype>2</ptype>-<clientpath>/home/mininet/demo/net/tcpFiles</clientpath>-<clientpathbak>/home/mininet/demo/net/tcpFiles</clientpathbak>-<andchild>true</andchild><matchname>*.XML,*.CSV</matchname><srvpath>/home/mininet/demo/net/tcpFiles/temp</srvpath><timetvl>10</timetvl><timeout>50</timeout><pname>tcpputfiles_surfdata</pname>\"\n\n\n");

  printf("本程序是数据中心的公共功能模块，采用tcp协议把文件发送给服务端。\n");
  printf("logfilename   本程序运行的日志文件。\n");
  printf("xmlbuffer     本程序运行的参数，如下：\n");
  printf("server ip     服务端的IP地址。\n");
  printf("server port   服务端的端口。\n");
  printf("ptype         文件上传成功后的处理方式：1-删除文件；2-移动到备份目录。\n");
  printf("clientpath    本地文件存放的根目录。\n");
  printf("clientpathbak 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。\n");
  printf("andchild      是否上传clientpath目录下各级子目录的文件，true-是；false-否，缺省为false。\n");
  printf("matchname     待上传文件名的匹配规则，如\"*.TXT,*.XML\"\n");
  printf("srvpath       服务端文件存放的根目录。\n");
  printf("timetvl       扫描本地目录文件的时间间隔，单位：秒，取值在1-30之间。\n");
  printf("timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\n");
  printf("pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\n\n");
  
  //printf("test!!!!!!!!");
}

// 把xml解析到参数starg结构
bool _xmltoArg(char *strxmlBuffer)
{
  memset(&starg,0,sizeof(struct st_arg));

  GetXMLBuffer(strxmlBuffer,"ip",starg.ip);
  if (strlen(starg.ip)==0) { logfile.Write("ip is null.\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"port",&starg.port);
  if ( starg.port==0) { logfile.Write("port is null.\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"ptype",&starg.ptype);
  if ((starg.ptype!=1)&&(starg.ptype!=2)) { logfile.Write("ptype not in (1,2).\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"clientpath",starg.clientpath);
  if (strlen(starg.clientpath)==0) { logfile.Write("clientpath is null.\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"clientpathbak",starg.clientpathbak);
  if ((starg.ptype==2)&&(strlen(starg.clientpathbak)==0)) { logfile.Write("clientpathbak is null.\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"andchild",&starg.andchild);

  GetXMLBuffer(strxmlBuffer,"matchname",starg.matchname);
  if (strlen(starg.matchname)==0) { logfile.Write("matchname is null.\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"srvpath",starg.srvpath);
  if (strlen(starg.srvpath)==0) { logfile.Write("srvpath is null.\n"); return false; }

  GetXMLBuffer(strxmlBuffer,"timetvl",&starg.timetvl);
  if (starg.timetvl==0) { logfile.Write("timetvl is null.\n"); return false; }

  // 扫描本地目录文件的时间间隔，单位：秒。
  // starg.timetvl没有必要超过30秒。
  if (starg.timetvl>30) starg.timetvl=30;

  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。
  GetXMLBuffer(strxmlBuffer,"timeout",&starg.timeout);
  if (starg.timeout==0) { logfile.Write("timeout is null.\n"); return false; }
  if (starg.timeout<50) starg.timeout=50;

  GetXMLBuffer(strxmlBuffer,"pname",starg.pname,50);
  if (strlen(starg.pname)==0) { logfile.Write("pname is null.\n"); return false; }

  return true;
}
